{
  "language": "Solidity",
  "sources": {
    "contracts/GaugeRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport {Proxied} from \"./vendor/proxy/Proxied.sol\";\n\ncontract GaugeRegistry is Proxied {\n    address[] public gauges;\n    mapping(address => address) public gaugeToVault;\n\n    event AddGauge(address gauge, address vault);\n    event RemoveGauge(address gauge, address vault);\n\n    constructor() {} // solhint-disable no-empty-blocks\n\n    function addGauge(address newGauge, address vault) external onlyProxyAdmin {\n        require(\n            gaugeToVault[newGauge] == address(0),\n            \"GaugeRegistry: gauge already added\"\n        );\n        gauges.push(newGauge);\n        gaugeToVault[newGauge] = vault;\n        emit AddGauge(newGauge, vault);\n    }\n\n    function removeGauge(address gauge) external onlyProxyAdmin {\n        _removeFromArray(gauge);\n        emit RemoveGauge(gauge, gaugeToVault[gauge]);\n        delete gaugeToVault[gauge];\n    }\n\n    function _removeFromArray(address target) internal {\n        uint256 index = 1 ether;\n        address[] memory _gauges = gauges;\n        for (uint256 i = 0; i < _gauges.length; i++) {\n            if (_gauges[i] == target) {\n                index = i;\n                break;\n            }\n        }\n        require(index < 1 ether, \"GaugeRegistry: element not found\");\n        gauges[index] = _gauges[_gauges.length - 1];\n        gauges.pop();\n    }\n}"
    },
    "contracts/vendor/proxy/Proxied.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.7;\n\nabstract contract Proxied {\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\n    /// It also allows these functions to be called inside a contructor\n    /// even if the contract is meant to be used without proxy\n    modifier proxied() {\n        address proxyAdminAddress = _proxyAdmin();\n        // With hardhat-deploy proxies\n        // the proxyAdminAddress is zero only for the implementation contract\n        // if the implementation contract want to be used as a standalone/immutable contract\n        // it simply has to execute the `proxied` function\n        // This ensure the proxyAdminAddress is never zero post deployment\n        // And allow you to keep the same code for both proxied contract and immutable contract\n        if (proxyAdminAddress == address(0)) {\n            // ensure can not be called twice when used outside of proxy : no admin\n            // solhint-disable-next-line security/no-inline-assembly\n            assembly {\n                sstore(\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n                )\n            }\n        } else {\n            require(msg.sender == proxyAdminAddress);\n        }\n        _;\n    }\n\n    modifier onlyProxyAdmin() {\n        require(msg.sender == _proxyAdmin(), \"NOT_AUTHORIZED\");\n        _;\n    }\n\n    function _proxyAdmin() internal view returns (address adminAddress) {\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            adminAddress := sload(\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\n            )\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}